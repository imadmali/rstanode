
f <- function(y, t, p) {
  dy1 = y2
  dy2 = -y1 - theta1 * y2
}

f2 <- function(y, t, p) {
  dy1 <- theta1 * y1 + y2 * y3
  dy2 <- theta2 * (y2 - y3)
  dy3 <- -y1*y2 + (theta3)^2*y2 - y3
}

f3 <- function(y, t, p) {
  dy1 <- ((y1 + theta1)^2 + y2^2)^(3/2)
  dy2 <- ((y1 - theta2)^2 + y2^2)^(3/2)
  # dy1 <- dy1
  # dy2 <- dy2
  dy3 <- y1 + 2*dy2 - theta2 * ((y1 + theta1)/dy1) - theta1 * ((y1 - theta2)/ dy2)
  dy4 <- y2 - 2*dy1 - theta2 * (y2/dy1) - theta1 * (y2/dy2)
}

# extract and clean ode equations in user defined function
clean_f <- function(x) {
  sep <- deparse(body(x), width.cutoff = 300)
  beginning <- which(sep == "{") + 1
  end <- which(sep == "}") - 1
  out <- sep[beginning:end]
  out <- gsub(" ", "", out)
  for(i in 1:length(out)) {
    out[i] <- paste0(out[i], ";")
  }
  out
}

# convert ode functions to Stan syntax
trans_f <- function(x, n_theta, n_y) {
  out <- x
  for(j in 1:length(x)) {
    for (i in 1:n_y) {
      out[j] <- gsub("<-", "=", out[j])
      out[j] <- gsub(paste0("y",i), paste0("y[",i,"]"), out[j])
      out[j] <- gsub(paste0("dy\\[",i,"\\]"), paste0("dy_dt[",i,"]"), out[j])
    }
    for (k in 1:n_theta) {
      out[j] <- gsub(paste0("theta[",k,"]"), paste0("theta[",k,"]"), out[j])
    }
  }
  out
}

# write function to Stan file to use as #include in ode.stan
write_to_stan <- function(x) {
  n_eq <- length(x)
  out <- c("// generated by write_to_stan(); do not edit manually",
           paste0("real dy_dt[",n_eq,"];"),
           x,
           "return dy_dt;")
  writeLines(out, "user_ode_func.stan")
}

clean_f(f)
trans_f(clean_f(f), 2, 2)
write_to_stan(trans_f(clean_f(f), 2, 2))

# ode_model <- stan_model(stanc_ret = stanc_builder("sho.stan"))
# del <- sampling(ode_model, data = sim_data, chains = 1, iter = 1, algorithm = "Fixed_param")
# del <- extract(del)
