
f <- function(y, t, p) {
  dy1 <- y2
  dy2 <- -y1 - theta1 * y2
  return(dy1 = dy1, dy2 = dy2)
}

f2 <- function(y, t, p) {
  dy1 <- theta1 * y1 + y2 * y3
  dy2 <- theta2 * (y2 - y3)
  dy3 <- -y1*y2 + (theta3)^2*y2 - y3
}

f3 <- function(y, t, p) {
  dy1 <- ((y1 + theta1)^2 + y2^2)^(3/2)
  dy2 <- ((y1 - theta2)^2 + y2^2)^(3/2)
  # dy1 <- dy1
  # dy2 <- dy2
  dy3 <- y1 + 2*dy2 - theta2 * ((y1 + theta1)/dy1) - theta1 * ((y1 - theta2)/ dy2)
  dy4 <- y2 - 2*dy1 - theta2 * (y2/dy1) - theta1 * (y2/dy2)
}

formals <- formalArgs(f)

n_eqn <- length(equations)

# user-facing stan_ode function
stan_lines <- function(func, state, pars, times) {
  state_names <- names(state)
  pars_names <- names(pars)
  map <- list(state = cbind("stan" = paste0("y[", 1:length(state_names), "]"), "user" = state_names),
              pars = cbind("stan" = paste0("theta[", 1:length(pars_names), "]"), "user" = pars_names),
              n_states = length(state_names),
              n_pars= length(pars_names))
  f_out <- clean_f(func)
  f_out <- clean_operator(f_out)
  map$lhs <- cbind("stan" = paste0("dydt[", 1:length(get_lhs(f_out)), "]"), "user" = get_lhs(f_out))
  f_out <- trans_vars(f_out, map)
  return(f_out)
}

# extract and clean ode equations in user defined function
clean_f <- function(obj) {
  separate <- deparse(body(obj))
  separate <- gsub("[[:space:]]", "", separate)
  equations <- separate[-grep("[{}]", separate)]
  return_sel <- grep("return", equations)
  if (length(return_sel)==0)
    return(equations)
  else
    return(equations[-return_sel])
}

# cleanup assignment operator
clean_operator <- function(eqn) {
  n_eqn <- length(eqn)
  out <- NULL
  for (i in 1:n_eqn)
    out[i] <- gsub("<-", "=", eqn[i])
  return(out)
}

# get the derivatives with respect to time as defined by the user
get_lhs <- function(eqn) {
  eqn_split <- strsplit(eqn, "=")
  lhs <- sapply(eqn_split, "[[", 1)
  return(lhs)
}


# translate state and parameter variables from R to Stan
trans_vars <- function(eqn, map) {
  n_eqn <- length(eqn)
  out <- NULL
  for (i in 1:n_eqn) {
    eqn_trim <- trim(eqn[i])
    out[i] <- paste0(swap(eqn_trim, map), collapse = "")
  } 
  return(out)
}

# replace lhs, state, and pars with the stan appropriate values
swap <- function(eqn_trim, map) {
  n_eqn_line <- length(eqn_trim)
  for (i in 1:n_eqn_line) {
    clean_val <- gsub("[[:punct:]]", "", eqn_trim[i])
    sel_lhs <- which(map$lhs[,"user"] == clean_val)
    sel_state <- which(map$state[,"user"] == clean_val)
    sel_pars <- which(map$pars[,"user"] == clean_val)
    if (length(sel_lhs) > 0)
      eqn_trim[i] <- gsub(clean_val, map$lhs[sel_lhs, "stan"], eqn_trim[i])
    if (length(sel_state) > 0)
      eqn_trim[i] <- gsub(clean_val, map$state[sel_state, "stan"], eqn_trim[i])
    if (length(sel_pars) > 0)
      eqn_trim[i] <- gsub(clean_val, map$pars[sel_pars, "stan"], eqn_trim[i])
  }
  return(eqn_trim)
}

# split the equation at each operator (keeping the operator)
trim <- function(eqn_line) {
  out <- unlist(strsplit(eqn_line, "(?<=[[:punct:]])", perl=TRUE))
  return(out)
} 

# convert ode functions to Stan syntax
# trans_f <- function(x, n_theta, n_y) {
#   out <- x
#   for(j in 1:length(x)) {
#     for (i in 1:n_y) {
#       out[j] <- gsub("<-", "=", out[j])
#       out[j] <- gsub(paste0("y",i), paste0("y[",i,"]"), out[j])
#       out[j] <- gsub(paste0("dy\\[",i,"\\]"), paste0("dy_dt[",i,"]"), out[j])
#     }
#     for (k in 1:n_theta) {
#       out[j] <- gsub(paste0("theta[",k,"]"), paste0("theta[",k,"]"), out[j])
#     }
#   }
#   out
# }

stan_lines(f, state = c("y1" = 2, "y2" = 5), pars = c("theta1" = 0.5), times = seq(1,10,by=0.01))
stan_lines(f2, state = c("y1" = 2, "y2" = 5, "y3" = 8),
         pars = c("theta1" = 0.5, "theta2" = 0.2, "theta3" = 0.8),
         times = seq(1,10,by=0.01))

stan_lines(f3, state = c("y1" = 2, "y2" = 5),
         pars = c("theta1" = 0.5, "theta2" = 0.2),
         times = seq(1,10,by=0.01))


# write function to Stan file to use as #include in ode.stan
write_to_stan <- function(x) {
  n_eq <- length(x)
  out <- c("// generated by write_to_stan(); do not edit manually",
           paste0("real dy_dt[",n_eq,"];"),
           x,
           "return dy_dt;")
  writeLines(out, "user_ode_func.stan")
}

clean_f(f)
trans_f(clean_f(f), 2, 2)
write_to_stan(trans_f(clean_f(f), 2, 2))

# ode_model <- stan_model(stanc_ret = stanc_builder("sho.stan"))
# del <- sampling(ode_model, data = sim_data, chains = 1, iter = 1, algorithm = "Fixed_param")
# del <- extract(del)
